" vim:fdm=marker:ts=2:sw=2:et:

 " General basic necessary plugins
set nocompatible                "Be iMproved, required
set backspace=indent,eol,start  "Make backspace behave well
syntax on                       "Enable syntax highlighting
filetype plugin indent on       "Enable file type detection and do language-dependent indenting.
so ~/.vim/plugins.vim           " Source the plugins file

" Section: General config {{{1
"------------------------------------------------------------------------------

syntax enable

let mapleader = ','
set smartindent
set number
set relativenumber
set expandtab
set tabstop=2
set softtabstop=2                        " Insert mode
set shiftwidth=2                         " Spaces when using < and >
set complete=.,w,b,u                     " Autocomplete looks through current buffer, window, loaded buffers, unloaded buffers
set wildmenu
set wildignore+=*/tmp/*,*.so,*.swp,*.zip

silent! set foldmethod=marker " Use braces by default"
" set nojoinspaces
" set foldmethod=marker

" What's that? https://github.com/statico/dotfiles/blob/202e30b23e5216ffb6526cce66a0ef4fa7070456/.vim/vimrc#L39
" nmap <C-e> :e#<CR>
"
" " Emacs-like bindings in command line -- `:help emacs-keys`
" cnoremap <C-a>  <Home>
" cnoremap <C-b>  <Left>
" cnoremap <C-f>  <Right>
" cnoremap <C-d>  <Del>
" cnoremap <C-e>  <End>
" cnoremap <M-b>  <S-Left>
" cnoremap <M-f>  <S-Right>
" cnoremap <M-d>  <S-right><Delete>
" cnoremap <Esc>b <S-Left>
" cnoremap <Esc>f <S-Right>
" cnoremap <Esc>d <S-right><Delete>
" cnoremap <C-g>  <C-c>"

" Why not use the space or return keys to toggle folds?
" nnoremap <M-f> za
" vnoremap <M-f> zf

nnoremap <space> :

set autoread
runtime! macros/matchit.vim

set mouse=a 
set clipboard=unnamed

" Map ctrl+s to save
nmap <c-s> :w<CR>
imap <c-s> <Esc>:w<CR>
" Substitute word under the cursor
nnoremap <Leader>s :%s/\<<C-r><C-w>\>//g<Left><Left>



" Move up and down by screen line
nmap k gk
nmap j gj

map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)



" Section: Visual {{{1
"------------------------------------------------------------------------------

" dfferent colorscheme for ruby and markdown, for example
" autocmd FileType ruby colorscheme railcasts

set laststatus=2                         "Always display the status bar

" Make sure colored syntax mode is on, and make it Just Work with newer 256
" color terminals like iTerm2.
set background=dark
let g:rehash256 = 1
" colorscheme molokai
" colorscheme wombat
" colorscheme badwolf
" colorscheme onedark
colorscheme PaperColor
" colorscheme Tomorrow-Night-Eighties
" colorscheme one
" colorscheme tender


if !has('gui_running')
  if $TERM == "xterm-256color" || $TERM == "screen-256color" || $COLORTERM == "gnome-terminal"
    set t_Co=256
  elseif has("terminfo")
    colorscheme default
    set t_Co=8
    set t_Sf=[3%p1%dm
    set t_Sb=[4%p1%dm
  else
    colorscheme default
    set t_Co=8
    set t_Sf=[3%dm
    set t_Sb=[4%dm
  endif
  " Disable Background Color Erase when within tmux - https://stackoverflow.com/q/6427650/102704
  if $TMUX != ""
  endif
endif

" function! CleanBg()
"     hi Normal ctermbg=NONE
"     hi nonText ctermbg=NONE
"     hi SignColumn ctermbg=NONE
"     hi TabLineFill ctermbg=NONE
" endfunction

" autocmd FileType php colorscheme jellybeans NEED TO RERUN THE BG NONE!

" highlight LineNr ctermfg=DarkGrey
highlight Normal ctermbg=NONE
" hi nonText ctermbg=NONE
highlight SignColumn ctermbg=NONE
" highlight TabLineFill ctermfg=LightGreen ctermbg=darkBlue
" highlight TabLine ctermfg=Blue ctermbg=Yellow
" highlight TabLineSel ctermfg=Red ctermbg=Yellow
" highlight Normal ctermbg=darkBlue
highlight StatusLine   cterm=NONE ctermbg=blue ctermfg=white
highlight StatusLineNC cterm=NONE ctermbg=black ctermfg=white
highlight VertSplit    cterm=NONE ctermbg=black ctermfg=white

set nocursorline
set nocursorcolumn

"------Search
set hlsearch
set incsearch
set ignorecase
set smartcase


"------Splits
set splitbelow
set splitright



" Section: Functions {{{1
"------------------------------------------------------------------------------

function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'), 'file')
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction

function! IPhpInsertUse()
    call PhpInsertUse()
    call feedkeys('a',  'n')
endfunction

function! IPhpExpandClass()
    call PhpExpandClass()
    call feedkeys('a', 'n')
endfunction



" Section: Mappings {{{1
"------------------------------------------------------------------------------

" ctrl+s to save
nmap <C-s> :w<CR>

" ctrl+[hjkl] to move between panes
nmap <C-j> <C-w><C-j>
nmap <C-k> <C-w><C-k>
nmap <C-h> <C-w><C-h>
nmap <C-l> <C-w><C-l>

" ctrl+m to increment next number on the line
noremap     <C-m>               <C-a>

" noremap     <Space>             :

nnoremap    <Leader>]           :CtrlPTag<cr>
inoremap    <c-x><c-]>          <c-]>
nmap        <Leader>\|          :vsp<cr>
nmap        <Leader>-           :sp<cr>
nmap        <Leader><           :SyntasticToggleMode<cr>
nmap        <Leader>q           :cclose<CR>
nnoremap    <Leader>W           :res +10<CR>
nnoremap    <Leader>w           :res -10<CR>

nmap        <Leader>1           :NERDTreeToggle<cr>
nnoremap    <Leader>2           :TagbarToggle<CR>

" a for ack
nmap        <Leader>aa          :Ack<space>
nnoremap    <Leader>aw          :Ack <C-r><C-w><cr>

"e for edit
nmap        <Leader>ev          :tabedit ~/.vimrc<cr>
nmap        <Leader>ep          :tabedit ~/.vim/plugins.vim<cr>
nmap        <Leader>es          :tabedit ~/.vim/UltiSnips/

" f for file
map         <Leader>fr          :call RenameFile()<cr>

" g for go or git
nnoremap    <Leader>gr          :e bootstrap/routes.php<CR>
nnoremap    <Leader>gg          :Gstatus<CR>

" i for insert
nnoremap    <Leader>id          "=strftime("%Y-%m-%d %H:%M:%S")<CR>P
inoremap    <Leader>id          <C-R>=strftime("%Y-%m-%d %H:%M:%S")<CR>

" l for last
nnoremap    <Leader>ld          mz$x`z
nnoremap    <Leader>l;          mzA;<Esc>`z
nnoremap    <Leader>l,          mzA,<Esc>`z
nnoremap    <Leader>lr;         mz$r;`z
nnoremap    <Leader>lr,         mz$r,`z
nnoremap    <Leader>l<Space>    :%s/\s\+$//e<CR>

" n for numbers
map         <Leader>n           :set relativenumber<CR>
map         <Leader>N           :set norelativenumber<CR>

" p for php
inoremap    <Leader>pi          <Esc>:call IPhpInsertUse()<CR>
noremap     <Leader>pi          :call PhpInsertUse()<CR>
inoremap    <Leader>pe          <Esc>:call IPhpExpandClass()<CR>
noremap     <Leader>pe          :call PhpExpandClass()<CR>
noremap     <Leader>ps          :call PhpSortUse()<CR>

" r for replace
nnoremap    <Leader>rw          :%s/\<<C-r><C-w>\>//g<Left><Left>

" s for search
nmap        <Leader>sr          :CtrlPMRUFiles<cr>
nmap        <Leader>st          :CtrlPTag<cr>

" t for test
nnoremap    <silent><leader>tt  :TestNearest<CR>
nnoremap    <silent><leader>tT  :TestFile<CR>
nnoremap    <silent><leader>ta  :TestSuite<CR>
nnoremap    <silent><leader>tl  :TestLast<CR>
nnoremap    <silent><leader>tg  :TestVisit<CR>
nnoremap    <leader>tsb         :let test#strategy = 'basic'<CR>
nnoremap    <leader>tsd         :let test#strategy = 'dispatch'<CR>


nnoremap    [w                  :tabprevious<CR>
nnoremap    ]w                  :tabnext<CR>





"/ ----> PLUGINS
" Section: Plugins {{{1

"/ VimCommentary
autocmd FileType php setlocal commentstring=\/\/\ %s

"/ CtrlP
let g:ctrlp_extensions = ['tag']
let g:ctrlp_match_window = 'top,order:ttb,min:1,max:10,results:10'    " window to the top and other settings
let g:ctrlp_custom_ignore = '\v[\/](\.git|\.hg|node_modules|vendor)$' " ignore package managers huge folders
let g:ctrlp_custom_ignore = '\v[\/](\.git|\.hg|node_modules|vendor)$'

"/ NERDTree
" messing with vinegar...
let NERDTreeHijackNetrw = 0                                           

"/ Elm
let g:elm_format_autosave = 1

"/ VIM Test
" Dispatch to use the quickfix window. I like my terminal
let test#strategy = "dispatch"

"/ AutoPairs
let g:AutoPairsShortcutBackInsert = '<C-b>'

"/ Emmet
" Use ,, to trigger emmet
let g:user_emmet_leader_key=','

"/ UltiSnips
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<C-n>"
let g:UltiSnipsJumpBackwardTrigger="<C-p>"

"/ VimAck
let g:ackprg = 'ag --vimgrep'

"/ Supertab
let g:SuperTabLongestEnhanced=1
let g:SuperTabLongestHighlight=1

"/ Syntastic
" set statusline=%<%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P
" set statusline+=%#warningmsg#
" set statusline+=%{SyntasticStatuslineFlag()}
" set statusline+=%*

" let g:syntastic_always_populate_loc_list = 1
" let g:syntastic_auto_loc_list = 1
" let g:syntastic_check_on_open = 1
" let g:syntastic_check_on_wq = 0

"/ incsearch.vim
" :h g:incsearch#auto_nohlsearch
set hlsearch
let g:incsearch#auto_nohlsearch = 1
map n  <Plug>(incsearch-nohl-n)
map N  <Plug>(incsearch-nohl-N)
map *  <Plug>(incsearch-nohl-*)
map #  <Plug>(incsearch-nohl-#)
map g* <Plug>(incsearch-nohl-g*)
map g# <Plug>(incsearch-nohl-g#)"

" PHP
" let g:syntastic_php_checkers = ['php', 'phpcs']
" let g:syntastic_php_phpcs_args = "--standard=phpcs.xml"

" JS
" let g:syntastic_javascript_checkers = ['eslint']
" let g:syntastic_javascript_eslint_exe = 'eslint %'  " Just lint the current file

"/ ALE
let g:ale_sign_warning = '▲'
let g:ale_sign_error = '✗'

highlight link ALEWarningSign String
highlight link ALEErrorSign Title

let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'

let g:ale_linters = {
\  'php': ['phpcs', 'phpmd']
\}

" php
let g:ale_php_phpcs_standard = 'phpcs.xml'
let g:ale_php_phpmd_ruleset = 'phpmd.xml'

"/ Lightline
let g:lightline = {
\ 'colorscheme': 'wombat',
\ 'active': {
\   'left': [['mode', 'paste'], ['filename', 'modified']],
\   'right': [['lineinfo'], ['percent'], ['readonly', 'linter_warnings', 'linter_errors', 'linter_ok']]
\ },
\ 'component_expand': {
\   'linter_warnings': 'LightlineLinterWarnings',
\   'linter_errors': 'LightlineLinterErrors',
\   'linter_ok': 'LightlineLinterOK'
\ },
\ 'component_type': {
\   'readonly': 'error',
\   'linter_warnings': 'warning',
\   'linter_errors': 'error'
\ },
\ }

function! LightlineLinterWarnings() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ◆', all_non_errors)
endfunction

function! LightlineLinterErrors() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ✗', all_errors)
endfunction

function! LightlineLinterOK() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '✓ ' : ''
endfunction

autocmd User ALELint call s:MaybeUpdateLightline()

" Update and show lightline but only if it's visible (e.g., not in Goyo)
function! s:MaybeUpdateLightline()
  if exists('#lightline')
    call lightline#update()
  end
endfunction


"/ VimAck
" Use the silversearcher
let g:ackprg = 'ag --vimgrep'


"/ Autocorrect abbrev
iabbrev ret return
iabbrev rq request
iabbrev rs response
iabbrev reutrn return
iabbrev retrun return
iabbrev repsonse response
iabbrev gropu group


"/ Prettier
let g:prettier#autoformat = 0
autocmd BufWritePre *.js,*.jsx,*.mjs,*.ts,*.tsx,*.css,*.less,*.scss,*.json,*.graphql PrettierAsync


"/
"/ Custom text objects
"/
call textobj#user#plugin('function', {
\   '-': {
\     'select-a-function': 'CurrentFunctionA',
\     'select-a': 'af',
\   },
\ })

function! CurrentFunctionA()
  if getline('.') =~# '}'
    normal! k
  endif
  normal! ]M$
  let e = getpos('.')
  normal! [m
  call search('function', 'bW')
  normal! 0
  let b = getpos('.')
  if 1 < e[1] - b[1]
    return ['V', b, e]
  else
    return 0
  endif
endfunction

" function! CurrentFunctionI()
"   normal! ^
"   let head_pos = getpos('.')
"   normal! g_
"   let tail_pos = getpos('.')
"   let non_blank_char_exists_p = getline('.')[head_pos[2] - 1] !~# '\s'
"   return
"   \ non_blank_char_exists_p
"   \ ? ['v', head_pos, tail_pos]
"   \ : 0
" endfunction



"/
"/ gocom ----> AUTO-COMMANDS
"/

autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
autocmd FileType php setlocal ts=4 sts=4 sw=4 expandtab
autocmd FileType elm setlocal ts=4 sts=4 sw=4 expandtab

augroup autosourcing
    autocmd!
    autocmd BufWritePost .vimrc source %
augroup END
