
"  _   __(_)___ ___  __________
" | | / / / __ `__ \/ ___/ ___/
" | |/ / / / / / / / /  / /__
" |___/_/_/ /_/ /_/_/   \___/

" Section: Setup {{{1

" vim:fdm=marker:ts=2:sw=2:et:

" Section: Setup {{{1

 " General basic necessary plugins
set nocompatible                "Be iMproved, required
set backspace=indent,eol,start  "Make backspace behave well
syntax on                       "Enable syntax highlighting
filetype plugin indent on       "Enable file type detection and do language-dependent indenting.
so ~/.vim/plugins.vim           "Source the plugins file

"}}}

" Section: General config {{{1

syntax enable

let mapleader = ','
let maplocalleader = '\\'

set smartindent
set number
set relativenumber
set expandtab
set tabstop=2
set softtabstop=2                         " Insert mode
set shiftwidth=2                          " Spaces when using < and >
set complete=.,w,b,u                      " Autocomplete looks through current buffer, window, loaded buffers, unloaded buffers
set wildmenu
set wildignore+=*/tmp/*,*.so,*.swp,*.zip
set nojoinspaces
set listchars=tab:▸\ ,eol:¬               " Custom invisible chars

set foldmethod=marker                     " Use braces by default
set foldlevelstart=20                     " Do not open folds by default

set autoread                              " Update buffers if file changed outside of VIM

set nocursorline
set nocursorcolumn


" Search
set nohlsearch
set incsearch
set ignorecase
set smartcase


" Splits
set splitbelow
set splitright

set signcolumn=yes


runtime! macros/matchit.vim

silent! set mouse=nvc

set clipboard=unnamed

set nowrap
set showbreak=…                       " Nice ellipsis when wrapping lines

"}}}

" Section: Visual {{{1
"------------------------------------------------------------------------------

" dfferent colorscheme for ruby and markdown, for example
" autocmd FileType ruby colorscheme railcasts

set laststatus=2                         " Always display the status bar

" Make sure colored syntax mode is on, and make it Just Work with newer 256
" color terminals like iTerm2.
set background=dark
let g:rehash256 = 1
" colorscheme molokai
" colorscheme wombat
" colorscheme onedark
" colorscheme PaperColor
" colorscheme Tomorrow-Night-Eighties
" colorscheme one
" colorscheme tender

" autocmd FileType vue colorscheme molokai
" colorscheme PaperColor
" colorscheme molokai

colorscheme jellybeans

if !has('gui_running')
  if $TERM == "xterm-256color" || $TERM == "screen-256color" || $COLORTERM == "gnome-terminal"
    set t_Co=256
  elseif has("terminfo")
    colorscheme default
    set t_Co=8
    set t_Sf=[3%p1%dm
    set t_Sb=[4%p1%dm
  else
    colorscheme default
    set t_Co=8
    set t_Sf=[3%dm
    set t_Sb=[4%dm
  endif
  " Disable Background Color Erase when within tmux - https://stackoverflow.com/q/6427650/102704
  if $TMUX != ""
    set t_ut=
  endif
endif

highlight Normal ctermbg=NONE
highlight nonText ctermbg=NONE
highlight SignColumn ctermbg=NONE
highlight TabLineFill ctermbg=NONE

highlight CursorLineNr  ctermbg=NONE
highlight Normal        ctermbg=NONE
highlight nonText       ctermbg=NONE
highlight LineNr        ctermbg=NONE

" highlight SignColumn    ctermbg=NONE
" highlight TabLineFill ctermfg=LightGreen ctermbg=darkBlue
" highlight TabLine ctermfg=Blue ctermbg=Yellow
" highlight TabLineSel ctermfg=Red ctermbg=Yellow
" highlight Normal        cterm=NONE ctermbg=NONE
" highlight StatusLine    cterm=NONE ctermbg=blue ctermfg=white
" Fix the & command in normal and visual modes
nnoremap & :&&<Enter>
xnoremap & :&&<Enter>

" 1}}}

" Section: Mappings {{{1
"------------------------------------------------------------------------------

" Move up and down by screen line
noremap k gk
noremap j gj


inoremap jk <Esc>


map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)

command! Wip call VimuxRunCommand("u --group wip")
command! Source :source $MYVIMRC

nnoremap K     <nop>
nnoremap Q     <nop>

" Switch to previous buffer
nnoremap <C-e> :e#<CR>

"
" " Emacs-like bindings in command line -- `:help emacs-keys`
cnoremap <C-a>  <Home>
" cnoremap <C-b>  <Left>
" cnoremap <C-f>  <Right>
" cnoremap <C-d>  <Del>
cnoremap <C-e>  <End>
cnoremap <C-b>  <S-Left>
cnoremap <C-f>  <S-Right>
" cnoremap <M-d>  <S-right><Delete>
" cnoremap <Esc>b <S-Left>
" cnoremap <Esc>f <S-Right>
" cnoremap <Esc>d <S-right><Delete>
" cnoremap <C-g>  <C-c>"



" Why not use the space or return keys to toggle folds?
nnoremap <M-f> za
" vnoremap <M-f> zf
" nnoremap <cr> za

nnoremap <space> :


" ctrl+s to save
nnoremap <C-s> :w<CR>
inoremap <C-s> <Esc>:w<CR>

" in insert mode, uppercase the current word
inoremap <c-u> <esc>gUiwea

" ctrl+[hjkl] to move between panes
nnoremap <C-j> <C-w><C-j>
nnoremap <C-k> <C-w><C-k>
nnoremap <C-h> <C-w><C-h>
nnoremap <C-l> <C-w><C-l>

" ctrl+m to increment next number on the line
nnoremap     <C-m>               <C-a>

inoremap    <c-x><c-]>          <c-]>
nnoremap    <leader>]           :CtrlPTag<cr>
nmap        <leader>\|          :vsp<cr>
nmap        <leader>-           :sp<cr>
nnoremap    <leader>w           :res -10<CR>
nnoremap    <leader>W           :res +10<CR>

nnoremap    <leader>1           :NERDTreeToggle<cr>
nnoremap    <leader>2           :TagbarToggle<CR>

nnoremap    <leader>aa          :Ack<space>
nnoremap    <leader>aw          :Ack <C-r><C-w><space>
vnoremap    <leader>aw          y :Ack <C-r>"<space>

nnoremap    <leader>rr          :CtrlPMRU<cr>
nnoremap    <leader>b           :CtrlPBuffer<cr>
" inoremap    <C-k>               <esc>ysaW>yaW$pT<i/<esc>hi

" Insert Now or Date
nnoremap    <leader>n           "=strftime("%Y-%m-%d %H:%M:%S")<CR>P
inoremap    <leader>n           <C-R>=strftime("%Y-%m-%d %H:%M:%S")<CR>
nnoremap    <leader>d           "=strftime("%d/%m/%Y")<CR>P
inoremap    <leader>d           <C-R>=strftime("%d/%m/%Y")<CR>

"e for edit
nnoremap    <leader>ev          :tabedit $MYVIMRC<cr>
nmap        <leader>ep          :tabedit ~/.vim/plugins.vim<cr>
nmap        <leader>es          :tabedit ~/.vim/UltiSnips/
nnoremap    <Leader>ee          :edit ~/.texpander/<cr>

" nnoremap p =p
" nnoremap P =P

nmap        <Leader>i           vip:sort<CR>

" Git
nnoremap    <leader>g           :Gstatus<CR>

" Ladders
nnoremap   <leader>lr          :edit bootstrap/routes.php<CR>
nnoremap   <leader>lm          :edit src/Ladders/Database/Migrations<CR>
" Planizely
nnoremap    <leader>pr          :edit routes/api.php<cr>

" l for last
" TODO -> use a function that toggle the last character of the line
" nnoremap    <leader>ld          mz$x`z
" nnoremap    <leader>l;          mzA;<Esc>`z
" nnoremap    <leader>l,          mzA,<Esc>`z
" nnoremap    <leader>lr;         mz$r;`z
" nnoremap    <leader>lr,         mz$r,`z
" nnoremap    <leader>l<Space>    :%s/\s\+$//e<CR>

" p for php
nnoremap     <leader>pi          :call PhpInsertUse()<CR>
inoremap    <leader>pi          <Esc>:call IPhpInsertUse()<CR>
inoremap    <leader>pe          <Esc>:call IPhpExpandClass()<CR>
nnoremap    <leader>pe          :call PhpExpandClass()<CR>
nnoremap    <leader>ps          :call PhpSortUse()<CR>
nnoremap    <leader>pi          :call PhpInsertUse()<CR>
inoremap    <leader>pi          <Esc>:call IPhpInsertUse()<CR>

nnoremap    <leader>q           :cclose<CR>

" r for replace
nnoremap    <Leader>rw          :%s/\<<C-r><C-w>\>//g<Left><Left>
nnoremap        <Leader>rr          :CtrlPMRUFiles<cr>

nnoremap    <leader>tt  :TestNearest<CR>
nnoremap    <silent><leader>tf  :TestFile<CR>
nnoremap    <silent><leader>ta  :TestSuite<CR>
nnoremap    <silent><leader>tl  :TestLast<CR>
nnoremap    <silent><leader>tg  :TestVisit<CR>
nnoremap    <leader>tsb         :let test#strategy = 'basic'<CR>
nnoremap    <leader>tsd         :let test#strategy = 'dispatch'<CR>

nnoremap    <Leader>vq :VimuxCloseRunner<CR>
nnoremap <Leader>vz :call VimuxZoomRunner()<CR>
nnoremap <Leader>vi :VimuxInspectRunner<CR>
map <Leader>vl :VimuxRunLastCommand<CR>
map <Leader>vp :VimuxPromptCommand<CR>
nnoremap    <leader>vr          :call VimuxRunLastCommand()<CR>
nnoremap    <leader>vc          :call VimuxCloseRunner()<CR>

nnoremap    [w                  :tabprevious<CR>
nnoremap    ]w                  :tabnext<CR>

nnoremap   <leader>wt           :e test<CR>
nnoremap   <leader>zx           :ZZ


" Operator pending movement.
" Interesting. Keep in mind.
onoremap    p                   i(
onoremap    in(                 :<c-u>normal! f(vi(<cr>
onoremap    il(                 :<c-u>normal! F)vi(<cr>


"   w = whooks web
"   a = whooks api
"   p = planizely


"/
"/ 5: TIPS & TRICKS
"/

" Expand %% to current file directory in command line mode
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'


"}}}

" Section: Plugins {{{1
"------------------------------------------------------------------------------

"/ VimCommentary
autocmd FileType php setlocal commentstring=\/\/\ %s

"/ CtrlP
let g:ctrlp_extensions = ['tag']
let g:ctrlp_match_window = 'top,order:ttb,min:1,max:20,results:20'    " window to the top and other settings
let g:ctrlp_custom_ignore = '\v[\/](\.git|\.hg|node_modules|vendor|_build|deps|*.beam)$' " ignore package managers huge folders
let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
let g:ctrlp_use_caching = 0

"/ NERDTree
" messing with vinegar...
let NERDTreeHijackNetrw = 0

"/ VIM Test
" let test#strategy = "dispatch"
let test#strategy = "vimux"

"/ AutoPairs
let g:AutoPairsShortcutBackInsert = '<C-b>'

"/ Emmet
" Use `,,` to trigger emmet
" TODO -> get rid of emmet for more simple tag solution?
" let g:user_emmet_leader_key=','

"/ UltiSnips
let g:UltiSnipsExpandTrigger="<tab>"

"/ Supertab
let g:SuperTabLongestEnhanced=1
let g:SuperTabLongestHighlight=1



"/ incsearch.vim
" :h g:incsearch#auto_nohlsearch
set hlsearch
let g:incsearch#auto_nohlsearch = 1
map n  <Plug>(incsearch-nohl-n)
map N  <Plug>(incsearch-nohl-N)
map *  <Plug>(incsearch-nohl-*)
map #  <Plug>(incsearch-nohl-#)
map g* <Plug>(incsearch-nohl-g*)
map g# <Plug>(incsearch-nohl-g#)"


"/ vimux
let g:VimuxOrientation = "h"
let g:VimuxHeight = "30"



"/ Gitgutter
highlight GitGutterAdd ctermfg=darkgreen ctermbg=NONE
highlight GitGutterChange ctermfg=yellow ctermbg=NONE
highlight GitGutterDelete ctermfg=darkred ctermbg=NONE
" highlight GitGutterChangeDelete ctermfg=lightgreen ctermbg=NONE


"/ ALE
let g:ale_sign_warning = '▲'
let g:ale_sign_error = '✗'
highlight NiceError ctermfg=red ctermbg=NONE
highlight NiceWarning ctermfg=yellow ctermbg=NONE
highlight link ALEWarningSign NiceWarning
highlight link ALEErrorSign NiceError


let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'

let g:ale_fix_on_save = 1
nmap <F8> <Plug>(ale_fix)

let g:ale_linters = {
\  'php': ['php', 'phpcs', 'phpmd', 'phpstan']
\}

let g:ale_fixers = {
\   'elm': [
\       'format'
\   ],
\   'javascript': [
\       'eslint'
\   ]
\}

" php
let g:ale_php_phpcs_standard = 'phpcs.xml'
let g:ale_php_phpmd_ruleset = 'phpmd.xml'



"/ Lightline
let g:lightline = {
\ 'colorscheme': 'jellybeans',
\ 'active': {
\   'left': [['mode', 'paste'], ['filename', 'modified']],
\   'right': [['lineinfo'], ['percent'], ['readonly', 'linter_warnings', 'linter_errors', 'linter_ok']]
\ },
\ 'component_expand': {
\   'linter_warnings': 'LightlineLinterWarnings',
\   'linter_errors': 'LightlineLinterErrors',
\   'linter_ok': 'LightlineLinterOK'
\ },
\ 'component_type': {
\   'readonly': 'error',
\   'linter_warnings': 'warning',
\   'linter_errors': 'error'
\ },
\ }

function! LightlineLinterWarnings() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ◆', all_non_errors)
endfunction

function! LightlineLinterErrors() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ✗', all_errors)
endfunction

function! LightlineLinterOK() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '✓ ' : ''
endfunction

autocmd User ALELint call s:MaybeUpdateLightline()

" Update and show lightline but only if it's visible (e.g., not in Goyo)
function! s:MaybeUpdateLightline()
  if exists('#lightline')
    call lightline#update()
  end
endfunction


"/ VimAck
let g:ackprg = 'ag --vimgrep'


"/ Autocorrect abbrev
iabbrev r return
iabbrev return NOPENOPENOPE
iabbrev rq request
iabbrev rs response
iabbrev f function
iabbrev reutrn return
iabbrev retrun return
iabbrev repsonse response
iabbrev gropu group



"/ Splitjoin
let g:splitjoin_split_mapping = ''
let g:splitjoin_join_mapping = ''
nnoremap <Leader>j :SplitjoinJoin<cr>
nnoremap <Leader>s :SplitjoinSplit<cr>



"/
"/ Custom text objects
"/
call textobj#user#plugin('function', {
\   '-': {
\     'select-a-function': 'CurrentFunctionA',
\     'select-a': 'af',
\   },
\ })

function! CurrentFunctionA()
  if getline('.') =~# '}'
    normal! k
  endif
  normal! ]M$
  let e = getpos('.')
  normal! [m
  call search('function', 'bW')
  normal! 0
  let b = getpos('.')
  if 1 < e[1] - b[1]
    return ['V', b, e]
  else
    return 0
  endif
endfunction



" vim-tmuxify
" https://github.com/jebaum/vim-tmuxify
let g:tmuxify_run = {
\   'php': 'phpunit %',
\   'js': 'jest %'
\ }


"/ VDebug
let g:vdebug_options = {
\   "port" : 9001
\}

" casestrate
let g:casetrate_leader = '<leader>c'

" function! CurrentFunctionI()
"   normal! ^
"   let head_pos = getpos('.')
"   normal! g_
"   let tail_pos = getpos('.')
"   let non_blank_char_exists_p = getline('.')[head_pos[2] - 1] !~# '\s'
"   return
"   \ non_blank_char_exists_p
autocmd BufEnter *.js iabbr zzz console.log('ZZZ',
autocmd BufEnter *.vue iabbr xxx console.log('XXX',
autocmd BufEnter *.vue iabbr yyy console.log('YYY',
autocmd BufEnter *.vue iabbr zzz console.log('ZZZ',
autocmd BufEnter .vimlocal set filetype=vim

" Section: Functions {{{1
"------------------------------------------------------------------------------

function! IPhpInsertUse()
    call PhpInsertUse()
    call feedkeys('a',  'n')
endfunction

function! IPhpExpandClass()
    call PhpExpandClass()
    call feedkeys('a', 'n')
endfunction

" 1}}}

" Section: Auto commands {{{1

augroup autosyntax
  autocmd!
  autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
  autocmd FileType php setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType python setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType elm setlocal ts=4 sts=4 sw=4 expandtab
augroup END

" augroup specialabbrev
"   autocmd!
"   autocmd FileType php :iabbrev <buffer> $ $this->
" augroup END

augroup html
  autocmd!
  " fold with \ f
  autocmd FileType html nnoremap <buffer> <localleader>f Vatzf
augroup END


"/ Vim vue
" Prevent syntax highlighting quirks
autocmd FileType vue syntax sync fromstart

" Enable that with Elixir 1.6! or try to use it with ALE
" autocmd BufWritePost *.exs silent :!mix format %
" autocmd BufWritePost *.ex silent :!mix format %

" Trim trailing spaces
autocmd BufWritePre * %s/\s\+$//e

" Experimental stuff {{{1

" A function that toggles the last character of the line
function! ToggleLast()
  let line = getline('.')
  let last = strpart(line, strlen(line) - 1)
  echo 'yay'
  " normal mz$
  " if last == ';'
  "   normal r,
  " elseif last == ','
  "   normal x
  " else
  "   normal a;
  " endif
  " normal `z
endfunction

nnoremap <silent> <leader>l :call ToggleLast()<cr>

" }}}

augroup autosourcing
    autocmd!
    " autocmd BufWritePost .vimrc source $MYVIMRC
    " autocmd BufWritePost call Source()
augroup END

"/ DBExt
let g:dbext_default_profile_mysql_ll = 'type=MYSQL:host=db:user=root:passwd=rootyroot:dbname=learningladders'
let g:dbext_default_window_width = 50

augroup learningladders
    autocmd!
    autocmd BufRead */learning-ladders/* DBSetOption profile=mysql_ll
augroup END
